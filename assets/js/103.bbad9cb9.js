(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{269:function(e,t,n){e.exports=n.p+"assets/img/markdown-img-paste-2019092622160321.c35f28fc.png"},743:function(e,t,n){"use strict";n.r(t);var s=n(2),r=Object(s.a)({},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"_190-商品详情页-oneservice-系统：多服务接口合并设计介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_190-商品详情页-oneservice-系统：多服务接口合并设计介绍","aria-hidden":"true"}},[e._v("#")]),e._v(" 190. 商品详情页 OneService 系统：多服务接口合并设计介绍")]),e._v(" "),s("p",[e._v("之前我们都跟大家说过了，可能页面中需要相关联的几份数据，就不用一次又一次的发送 ajax 请求来获取多份数据，\n直接就是一次请求发给一个 one service 系统的大接口，然后那个接口统一调用各个后端服务的接口就可以")]),e._v(" "),s("p",[s("strong",[e._v("目的：")]),e._v(" 减少浏览器和后端系统之间的交互次数")]),e._v(" "),s("p",[e._v("那么将哪些接口合并为一个接口呢？如何来设计接口的合并呢？")]),e._v(" "),s("p",[e._v("这个策略就很多，一般常见的策略是根据相邻的位置（页面中 ui 展示相邻的合并为一个接口），\n比如第一屏有促销和部分广告，可以合并一下，在第一屏这两个一次就能拿回来需要展示的数据")]),e._v(" "),s("p",[e._v("还有比如以下的业务合并等")]),e._v(" "),s("ul",[s("li",[e._v("促销和广告，合并成一个接口，一次性发送请求过来，然后调用促销服务和广告服务，获取两份数据")]),e._v(" "),s("li",[e._v("库存服务，配送服务，合并成一个接口，一次性过来，获取当前有多少库存，如何配送")]),e._v(" "),s("li",[e._v("组合推荐服务+配件推荐服务+套装推荐服务，三个服务并发调用，合并结果")])]),e._v(" "),s("p",[s("img",{attrs:{src:n(269),alt:""}})]),e._v(" "),s("p",[e._v("如上图的推荐和广告很近，往下拉的时候，基本上都需要加载出来。就适合合并起来")])])},[],!1,null,null,null);t.default=r.exports}}]);